; Standard Utilities Library
;
; Copyright (C) 2020 Kestrel Institute (http://www.kestrel.edu)
;
; License: A 3-clause BSD license. See the LICENSE file distributed with ACL2.
;
; Main Author: Alessandro Coglio (coglio@kestrel.edu)
; Contributing Author: Stephen Westfold (westfold@kestrel.edu)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package "ACL2")

(include-book "kestrel/event-macros/applicability-conditions" :dir :system)
(include-book "kestrel/event-macros/input-processing" :dir :system)
(include-book "kestrel/event-macros/xdoc-constructors" :dir :system)
(include-book "kestrel/std/system/conjoin-equalities" :dir :system)
(include-book "kestrel/std/system/make-mv-let-call" :dir :system)
(include-book "kestrel/std/system/make-mv-nth-calls" :dir :system)
(include-book "kestrel/std/system/pseudo-event-form-listp" :dir :system)
(include-book "kestrel/utilities/defthmr" :dir :system)
(include-book "kestrel/utilities/error-checking/top" :dir :system)
(include-book "kestrel/utilities/keyword-value-lists" :dir :system)
(include-book "kestrel/utilities/orelse" :dir :system)
(include-book "kestrel/utilities/user-interface" :dir :system)
(include-book "std/typed-alists/symbol-symbol-alistp" :dir :system)
(include-book "std/util/defaggregate" :dir :system)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-implementation

 defiso

 :item-state t

 :item-wrld t

 :item-ctx t

 :items

 ("@('name'),
   @('doma'),
   @('domb'),
   @('alpha'),
   @('beta'),
   @('unconditional'),
   @('guard-thms'),
   @('thm-names'),
   @('hints'),
   @('print'), and
   @('show-only')
   are the homonymous inputs to @(tsee defiso),
   before being validated.
   These formal parameters have no types because they may be any values."

  "@('name$'),
   @('doma$'),
   @('domb$'),
   @('alpha$'),
   @('beta$'),
   @('unconditional$'),
   @('guard-thms$'),
   @('thm-name$'),
   @('hints$'),
   @('print$'), and
   @('show-only$')
   are the results of processing
   the homonymous inputs (without the @('$')) to @(tsee defiso).
   Some are identical to the corresponding inputs,
   but they have types implied by their successful validation,
   performed when they are processed."

  "@('call') is the call to @(tsee defiso) supplied by the user."

  "@('call$') is the result of removing
   @(':print') and @(':show-only') from @('call')."

  "@('expansion') is the @(tsee encapsulate) generated by @(tsee defiso)."

  "@('a') and @('b') are variables to use in the generated theorems."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defxdoc+ defiso-table
  :parents (defiso-implementation)
  :short "@(csee table) of recorded @(tsee defiso) information."
  :long
  (xdoc::topstring
   (xdoc::p
    "For each successful call of @(tsee defiso)
     whose @(':show-only') input is not @('t'),
     this table includes a pair
     whose key is the name supplied as first input to @(tsee defiso)
     ans whose value includes the information about
     the domains, isomorphisms, and theorems
     (see @(tsee defiso-infop)).")
   (xdoc::p
    "This table is used
     not only to record the @(tsee defiso) information,
     but also to support the redundancy check
     in @(tsee defiso-check-redundancy)."))
  :order-subtopics t
  :default-parent t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *defiso-table-name*
  'defiso-table
  :short "Name of the @(tsee defiso) table.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(std::defaggregate defiso-info
  :short "Information about a @(tsee defiso) call,
          recorded as a pair's value in the @(tsee defiso) table."
  ((call$ "The call to @(tsee defiso), without @(':print') and @(':show-only')."
          pseudo-event-formp)
   (expansion "The @(tsee encapsulate) generated from
               the call to @(tsee defiso)."
              pseudo-event-formp)
   (doma "Domain @($A$), in translated form." pseudo-termfnp)
   (domb "Domain @($B$), in translated form." pseudo-termfnp)
   (alpha "Isomorphism @($\\alpha$), in translated form." pseudo-termfnp)
   (beta "Isomorphism @($\\beta$), in translated form." pseudo-termfnp)
   (alpha-image "Name of the @(':alpha-image') theorem." symbolp)
   (beta-image "Name of the @(':beta-image') theorem." symbolp)
   (beta-of-alpha "Name of the @(':beta-of-alpha') theorem." symbolp)
   (alpha-of-beta "Name of the @(':alpha-of-beta') theorem." symbolp)
   (alpha-injective "Name of the @(':alpha-injective') theorem." symbolp)
   (beta-injective "Name of the @(':beta-injective') theorem." symbolp)
   (doma-guard
    "Name of the @(':doma-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (domb-guard
    "Name of the @(':domb-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (alpha-guard
    "Name of the @(':alpha-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (beta-guard
    "Name of the @(':beta-guard') theorem, if present (otherwise @('nil'))."
    symbolp)
   (unconditional booleanp "Value of the @(':unconditional') input,
                            i.e. whether some of the theorems
                            are unconditional or not."))
  :pred defiso-infop)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(make-event
 `(table ,*defiso-table-name* nil nil
    :guard (and (symbolp key) ; NAME input of DEFISO
                (defiso-infop val))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define maybe-defiso-infop (x)
  :returns (yes/no booleanp)
  (or (defiso-infop x)
      (eq x nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-lookup ((name symbolp) (wrld plist-worldp))
  :returns (info? "A @(tsee maybe-defiso-infop).")
  :verify-guards nil
  :short "Return the information for the @(tsee defiso) specified by name,
          or @('nil') if there is no @(tsee defiso) with that name."
  (b* ((defiso-table (table-alist *defiso-table-name* wrld))
       (pair? (assoc-eq name defiso-table))
       ((when (null pair?)) nil)
       (info (cdr pair?)))
    info))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-filter-call ((call pseudo-event-formp))
  :guard (and (>= (len call) 6)
              (eq 'defiso (car call)))
  :returns (call$ "A @(tsee pseudo-event-formp).")
  :verify-guards nil
  :short "Remove any @(':print') and @(':show-only') inputs
          from a call to @(tsee defiso)."
  :long
  (xdoc::topstring-p
   "As explained in the documentation,
    these two options are ignored when checking redundancy.")
  (b* ((number-of-required-args 5)
       (number-of-elements-before-options (1+ number-of-required-args))
       (options (nthcdr number-of-elements-before-options call))
       (options (remove-keyword :print options))
       (options (remove-keyword :show-only options))
       (call$ (append (take number-of-elements-before-options call) options)))
    call$))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-input-processing defiso)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-process-name (name ctx state)
  :returns (mv erp (nothing null) state)
  :verify-guards nil
  :short "Process the @('name') input."
  (b* (((er &) (ensure-symbol$ name "The first input" t nil))
       ((er &) (ensure-symbol-not-keyword$ name "The first input" t nil)))
    (value nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-process-function
  ((function "The @('doma'), @('domb'), @('alpha'), or @('beta')
              input to @(tsee defiso).")
   (position (member position '(2 3 4 5))
             "Position of the input in the ordered inputs to @(tsee defiso).")
   (guard-thms$ booleanp)
   ctx
   state)
  :returns (mv erp
               (result "A tuple @('(function$
                                    arity
                                    numres)')
                        satisfying
                        @('(typed-tuplep pseudo-termfnp
                                         natp
                                         natp)').")
               state)
  :mode :program
  :short "Process one of the input functions
          (i.e. @('doma'), @('domb'), @('alpha'), or @('beta'))."
  :long
  (xdoc::topstring-p
   "Return either the input unchanged (if it is a function name)
    or its translation (if it is a lambda expression).
    Also return the arity and the number of results.")
  (b* (((er (list fn/lambda stobjs-in stobjs-out description))
        (ensure-function/macro/lambda$ function
                                       (msg "The ~n0 input" (list position))
                                       t nil))
       ((er &) (ensure-function/lambda-logic-mode$ fn/lambda description t nil))
       ((er &) (ensure-function/lambda-no-stobjs$ stobjs-in
                                                  stobjs-out
                                                  description t nil))
       ((er &) (ensure-function/lambda-closed$ fn/lambda description t nil))
       ((unless guard-thms$) (value (list fn/lambda
                                          (len stobjs-in)
                                          (len stobjs-out))))
       ((er &) (ensure-function/lambda-guard-verified-exec-fns$
                fn/lambda
                (msg
                 "Since the :GUARD-THMS input is (perhaps by default) T, ~@0"
                 (msg-downcase-first description))
                t nil)))
    (value (list fn/lambda
                 (len stobjs-in)
                 (len stobjs-out)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-process-functions (doma domb alpha beta guard-thms$ ctx state)
  :returns (mv erp
               (result "A tuple @('(doma$ domb$ alpha$ beta$)')
                        satisfying @('(typed-tuplep pseudo-termfnp
                                                    pseudo-termfnp
                                                    pseudo-termfnp
                                                    pseudo-termfnp
                                                    result)').")
               state)
  :mode :program
  :short "Process the @('doma'), @('domb'), @('alpha'), and @('beta') inputs."
  :long
  (xdoc::topstring-p
   "We call @(tsee defiso-process-function) on each
    and then we check the constraints on the arities and numbers of results.")
  (b* (((er (list doma$ doma-arity doma-numres))
        (defiso-process-function doma 2 guard-thms$ ctx state))
       ((er (list domb$ domb-arity domb-numres))
        (defiso-process-function domb 3 guard-thms$ ctx state))
       ((er (list alpha$ alpha-arity alpha-numres))
        (defiso-process-function alpha 4 guard-thms$ ctx state))
       ((er (list beta$ beta-arity beta-numres))
        (defiso-process-function beta 5 guard-thms$ ctx state))
       ((unless (= doma-numres 1))
        (er-soft+ ctx t nil
                  "The number of results returned by the domain ~x0 ~
                   must be 1, but it is ~x1 instead."
                  doma doma-numres))
       ((unless (= domb-numres 1))
        (er-soft+ ctx t nil
                  "The number of results returned by the domain ~x0 ~
                   must be 1, but it is ~x1 instead."
                  domb domb-numres))
       ((unless (= alpha-arity doma-arity))
        (er-soft+ ctx t nil
                  "The arity of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  alpha doma-arity doma alpha-arity))
       ((unless (= alpha-numres domb-arity))
        (er-soft+ ctx t nil
                  "The number of results of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  alpha domb-arity domb alpha-numres))
       ((unless (= beta-arity domb-arity))
        (er-soft+ ctx t nil
                  "The arity of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  beta domb-arity domb beta-arity))
       ((unless (= beta-numres doma-arity))
        (er-soft+ ctx t nil
                  "The number of results of the isomorphism ~x0 ~
                   must equal the arity ~x1 of the domain ~x2, ~
                   but it is ~x3 instead."
                  beta doma-arity doma beta-numres)))
    (value (list doma$ domb$ alpha$ beta$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defval *defiso-required-appcond-keywords*
  :short "Keywords that identify the required applicability conditions,
          i.e. the ones that are always present."
  (list :alpha-image
        :beta-image
        :beta-of-alpha
        :alpha-of-beta))

(defval *defiso-optional-appcond-keywords*
  :short "Keywords that identify the optional applicability conditions,
          i.e. the ones that may or may not be present."
  (list :doma-guard
        :domb-guard
        :alpha-guard
        :beta-guard))

(defval *defiso-additional-thm-keywords*
  :short "Keywords that identify the additional generated theorems
          (besides the ones for the applicability conditions)."
  (list :alpha-injective
        :beta-injective))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-thm-keywords ((guard-thms$ booleanp))
  :returns (thm-keywords symbol-listp)
  :short "Keywords that identify all the theorems to generate."
  (if guard-thms$
      (append *defiso-required-appcond-keywords*
              *defiso-optional-appcond-keywords*
              *defiso-additional-thm-keywords*)
    (append *defiso-required-appcond-keywords*
            *defiso-additional-thm-keywords*))
  ///

  (more-returns
   (thm-keywords no-duplicatesp-eq
                 :name no-duplicatesp-eq-of-defiso-thm-keywords)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-process-thm-names (thm-names
                                  (name$ symbolp)
                                  (guard-thms$ booleanp)
                                  ctx
                                  state)
  :returns (mv erp
               (thm-names$ "A @(tsee symbol-symbol-alistp).")
               state)
  :verify-guards nil
  :short "Process the @(':thm-names') input."
  :long
  (xdoc::topstring
   (xdoc::p
    "We compute the names for all the theorems to generate,
     and we return them as a complete alist
     from the keywords that identify the theorems
     to the corresponding theorem names.
     The alist has unique keys.")
   (xdoc::p
    "If an explicit theorem name is supplied in the @(':thm-names') input,
     it is used;
     otherwise, the theorem name is generated as explained in the documentation.
     The theorem names, whether generated or supplied,
     must be valid fresh theorem names.
     They must also be all distinct;
     this is always the case if the theorem names are all generated,
     because the keywords used in their names are all distinct."))
  (b* (((er &) (ensure-keyword-value-list$ thm-names
                                           "The :THM-NAMES input" t nil))
       (thm-names-alist (keyword-value-list-to-alist thm-names))
       (keys (strip-cars thm-names-alist))
       (description
        (msg "The list ~x0 of keywords of the :THM-NAMES input" keys))
       ((er &) (ensure-list-no-duplicates$ keys description t nil))
       (thm-keywords (defiso-thm-keywords guard-thms$))
       ((er &) (ensure-list-subset$ keys thm-keywords description t nil))
       ((er thm-names$) (defiso-process-thm-names-aux
                          thm-keywords thm-names-alist name$ ctx state))
       (vals (strip-cdrs thm-names$))
       (description (msg "The list ~x0 of theorem names, ~
                          some of which may be supplied ~
                          in the :THM-NAMES input,"
                         vals))
       ((er &) (ensure-list-no-duplicates$ vals description t nil)))
    (value thm-names$))

  :prepwork
  ((define defiso-process-thm-names-aux ((thm-keywords symbol-listp)
                                         (thm-names-alist symbol-alistp)
                                         (name$ symbolp)
                                         ctx
                                         state)
     :returns (mv erp
                  alist ; SYMBOL-SYMBOL-ALISTP
                  state)
     :verify-guards nil
     :parents nil ; override default
     (if (endp thm-keywords)
         (value nil)
       (b* ((thm-keyword (car thm-keywords))
            (pair (assoc-eq thm-keyword thm-names-alist))
            (thm-name (if pair
                          (cdr pair)
                        (add-suffix-to-fn name$
                                          (concatenate 'string
                                                       "."
                                                       (symbol-name
                                                        thm-keyword)))))
            (description (msg "The name ~x0 of the ~x1 theorem, ~@2,"
                              thm-name
                              thm-keyword
                              (if pair
                                  "supplied in the :THM-NAMES input"
                                "automatically generated")))
            ((er &) (ensure-symbol$ thm-name description t nil))
            ((er &) (ensure-symbol-new-event-name$ thm-name description t nil))
            ((er alist) (defiso-process-thm-names-aux
                          (cdr thm-keywords) thm-names-alist name$ ctx state)))
         (value (acons thm-keyword thm-name alist)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-process-inputs (name
                               doma
                               domb
                               alpha
                               beta
                               unconditional
                               guard-thms
                               thm-names
                               hints
                               print
                               show-only
                               ctx
                               state)
  :returns (mv erp
               (result "A tuple @('(doma$
                                    domb$
                                    alpha$
                                    beta$
                                    thm-names$
                                    hints$)')
                        satisfying
                        @('(typed-tuplep pseudo-termfnp
                                         pseudo-termfnp
                                         pseudo-termfnp
                                         pseudo-termfnp
                                         symbol-symbol-alistp
                                         symbol-truelist-alistp
                                         result)'),
                        where the first 4 components are
                        results of @(tsee defiso-process-functions),
                        @('thm-names$') is
                        the result of @(tsee defiso-process-thm-names), and
                        @('hints$') is
                        the result of @(tsee evmac-process-input-hints).")
               state)
  :mode :program
  :short "Process all the inputs."
  (b* (((er &) (defiso-process-name name ctx state))
       ((er &) (ensure-boolean$ guard-thms "The :GUARD-THMS input" t nil))
       ((er (list doma$ domb$ alpha$ beta$))
        (defiso-process-functions doma domb alpha beta guard-thms ctx state))
       ((er &) (ensure-boolean$ unconditional "The :UNCONDITIONAL input" t nil))
       ((er thm-names$) (defiso-process-thm-names
                          thm-names name guard-thms ctx state))
       ((er hints$) (evmac-process-input-hints hints ctx state))
       ((er &) (evmac-process-input-print print ctx state))
       ((er &) (evmac-process-input-show-only show-only ctx state)))
    (value (list doma$
                 domb$
                 alpha$
                 beta$
                 thm-names$
                 hints$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(xdoc::evmac-topic-event-generation defiso :some-local-nonlocal-p t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-var-a1...an ((alpha$ pseudo-termfnp)
                                (wrld plist-worldp))
  :returns (a1...an "A @(tsee symbol-listp).")
  :verify-guards nil
  :short "Generate the list of variables @('(a1 ... an)')
          described in the documentation."
  :long
  (xdoc::topstring
   (xdoc::p
    "We use the formal parameters of the isomorphism @($\\alpha$)."))
  (cond ((symbolp alpha$) (formals alpha$ wrld))
        (t (lambda-formals alpha$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-var-b1...bm ((beta$ pseudo-termfnp)
                                (wrld plist-worldp))
  :returns (b1...bm "A @(tsee symbol-listp).")
  :verify-guards nil
  :short "Generate the list of variables @('(b1 ... bm)')
          described in the documentation."
  :long
  (xdoc::topstring
   (xdoc::p
    "We use the formal parameters of the isomorphism @($\\beta$)."))
  (cond ((symbolp beta$) (formals beta$ wrld))
        (t (lambda-formals beta$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-differentiate-a/b-vars ((a1/b1...an/bm symbol-listp)
                                       (b1/a1...bm/an symbol-listp))
  :returns (a1/b1...an/bm-differentiated "A @(tsee symbol-listp).")
  :mode :program
  :short "Ensure that the variables
          @('a1'), ..., @('an') or @('b1'), ..., @('bm')
          do not overlap with
          @('b1'), ..., @('bm') or @('a1'), ..., @('an')."
  :long
  (xdoc::topstring
   (xdoc::p
    "In the formula of the @(':alpha-of-beta') applicability condition,
     in certain cases @('a1'), ..., @('an') are bound by @(tsee mv-let),
     and @('b1'), ..., @('bm') are used in the body of the @(tsee mv-let):
     if any @('bj') were identical to any @('ai'),
     the formula would be incorrect in general.
     A similar situation occurs
     with the @(':beta-of-alpha') applicability condition,
     with the roles of @('a1'), ..., @('an') and @('b1'), ..., @('bm') swapped.
     Thus, in these cases we may need to differentiate
     @('a1'), ..., @('an') apart from @('b1'), ..., @('bm') or vice versa.
     We do that here, using @(tsee genvar)."))
  (cond ((endp a1/b1...an/bm) nil)
        (t (b* ((a2/b2...an/bm-differentiated
                 (defiso-differentiate-a/b-vars
                   (cdr a1/b1...an/bm) b1/a1...bm/an))
                (a1/b1 (car a1/b1...an/bm))
                (a1/b1-differentiated
                 (genvar a1/b1
                         (symbol-name a1/b1)
                         nil
                         (append b1/a1...bm/an
                                 a2/b2...an/bm-differentiated))))
             (cons a1/b1-differentiated
                   a2/b2...an/bm-differentiated)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-var-aa/bb ((a1/b1...an/bm symbol-listp))
  :returns (aa1/bb1...aan/bbm "A @(tsee symbol-listp).")
  :mode :program
  :short "Generate the list of variables
          @('(aa1 ... aan)') or @('(bb1 ... bbm)')
          described in the documentation."
  :long
  (xdoc::topstring-p
   "We generate these by appending @('$') to each of
    @('(a1 ... an)') or @('(b1 ... bm)'),
    using @(tsee genvar) to ensure that we do not introduce clashes.")
  (cond ((endp a1/b1...an/bm) nil)
        (t (b* ((aa2/bb2...aan/bbm (defiso-gen-var-aa/bb
                                     (cdr a1/b1...an/bm)))
                (a1/b1 (car a1/b1...an/bm))
                (aa1/bb1 (genvar a1/b1
                                 (str::cat (symbol-name a1/b1) "$")
                                 nil
                                 (append a1/b1...an/bm aa2/bb2...aan/bbm))))
             (cons aa1/bb1 aa2/bb2...aan/bbm)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-appconds ((doma$ pseudo-termfnp)
                             (domb$ pseudo-termfnp)
                             (alpha$ pseudo-termfnp)
                             (beta$ pseudo-termfnp)
                             (a1...an symbol-listp)
                             (b1...bm symbol-listp)
                             (unconditional$ booleanp)
                             (guard-thms$ booleanp)
                             state)
  :returns (appconds "A @(tsee evmac-appcond-listp).")
  :mode :program
  :short "Generate the applicability conditions."
  (b* ((wrld (w state))
       (n (arity doma$ wrld))
       (m (arity domb$ wrld)))
    (append
     (make-evmac-appcond?
      :alpha-image
      (b* ((antecedent (apply-term doma$ a1...an))
           (consequent (if (= m 1)
                           (apply-term* domb$
                                        (apply-term alpha$ a1...an))
                         (make-mv-let-call 'mv
                                           b1...bm
                                           :all
                                           (apply-term alpha$ a1...an)
                                           (apply-term domb$ b1...bm)))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :beta-image
      (b* ((antecedent (apply-term domb$ b1...bm))
           (consequent (if (= n 1)
                           (apply-term* doma$
                                        (apply-term beta$ b1...bm))
                         (make-mv-let-call 'mv
                                           a1...an
                                           :all
                                           (apply-term beta$ b1...bm)
                                           (apply-term doma$ a1...an)))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :beta-of-alpha
      (b* ((antecedent (if unconditional$
                           *t*
                         (apply-term doma$ a1...an)))
           (consequent
            (if (= n 1)
                (if (= m 1)
                    (b* ((a (car a1...an)))
                      `(equal ,(apply-term* beta$
                                            (apply-term* alpha$
                                                         a))
                              ,a))
                  (b* ((b1...bm (defiso-differentiate-a/b-vars
                                  b1...bm a1...an)))
                    (make-mv-let-call 'mv
                                      b1...bm
                                      :all
                                      (apply-term* alpha$ (car a1...an))
                                      `(equal ,(apply-term beta$ b1...bm)
                                              ,(car a1...an)))))
              (if (= m 1)
                  (b* ((aa1...aan (defiso-gen-var-aa/bb a1...an)))
                    (make-mv-let-call 'mv
                                      aa1...aan
                                      :all
                                      (apply-term* beta$
                                                   (apply-term alpha$ a1...an))
                                      (conjoin-equalities aa1...aan a1...an)))
                (b* ((aa1...aan (defiso-gen-var-aa/bb a1...an))
                     (b1...bm (defiso-differentiate-a/b-vars
                                b1...bm a1...an)))
                  (make-mv-let-call
                   'mv
                   b1...bm
                   :all
                   (apply-term alpha$ a1...an)
                   (make-mv-let-call
                    'mv
                    aa1...aan
                    :all
                    (apply-term beta$ b1...bm)
                    (conjoin-equalities aa1...aan a1...an))))))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :alpha-of-beta
      (b* ((antecedent (if unconditional$
                           *t*
                         (apply-term domb$ b1...bm)))
           (consequent
            (if (= n 1)
                (if (= m 1)
                    (b* ((b (car b1...bm)))
                      `(equal ,(apply-term* alpha$
                                            (apply-term* beta$
                                                         b))
                              ,b))
                  (b* ((bb1...bbm (defiso-gen-var-aa/bb b1...bm)))
                    (make-mv-let-call 'mv
                                      bb1...bbm
                                      :all
                                      (apply-term* alpha$
                                                   (apply-term beta$ b1...bm))
                                      (conjoin-equalities bb1...bbm b1...bm))))
              (if (= m 1)
                  (b* ((b (car b1...bm))
                       (a1...an (defiso-differentiate-a/b-vars
                                  a1...an b1...bm)))
                    (make-mv-let-call 'mv
                                      a1...an
                                      :all
                                      (apply-term* beta$ b)
                                      `(equal ,(apply-term alpha$ a1...an)
                                              ,b)))
                (b* ((bb1...bbm (defiso-gen-var-aa/bb b1...bm))
                     (a1...an (defiso-differentiate-a/b-vars
                                a1...an b1...bm)))
                  (make-mv-let-call
                   'mv
                   a1...an
                   :all
                   (apply-term beta$ b1...bm)
                   (make-mv-let-call
                    'mv
                    bb1...bbm
                    :all
                    (apply-term alpha$ a1...an)
                    (conjoin-equalities bb1...bbm b1...bm))))))))
        (implicate antecedent consequent)))
     (make-evmac-appcond?
      :doma-guard
      (cond ((symbolp doma$) (uguard doma$ wrld))
            (t (term-guard-obligation (lambda-body doma$) state)))
      :when guard-thms$)
     (make-evmac-appcond?
      :domb-guard
      (cond ((symbolp domb$) (uguard domb$ wrld))
            (t (term-guard-obligation (lambda-body domb$) state)))
      :when guard-thms$)
     (make-evmac-appcond?
      :alpha-guard
      (b* ((alpha-formals
            (cond ((symbolp alpha$) (formals alpha$ wrld))
                  (t (lambda-formals alpha$))))
           (alpha-guard
            (cond ((symbolp alpha$) (uguard alpha$ wrld))
                  (t (term-guard-obligation (lambda-body alpha$) state)))))
        (implicate (apply-term doma$ a1...an)
                   (subcor-var alpha-formals
                               a1...an
                               alpha-guard)))
      :when guard-thms$)
     (make-evmac-appcond?
      :beta-guard
      (b* ((beta-formals
            (cond ((symbolp beta$) (formals beta$ wrld))
                  (t (lambda-formals beta$))))
           (beta-guard
            (cond ((symbolp beta$) (uguard beta$ wrld))
                  (t (term-guard-obligation (lambda-body beta$) state)))))
        (implicate (apply-term domb$ b1...bm)
                   (subcor-var beta-formals
                               b1...bm
                               beta-guard)))
      :when guard-thms$))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-appcond-thm ((appcond evmac-appcondp)
                                (appcond-thm-names symbol-symbol-alistp)
                                (thm-names$ symbol-symbol-alistp)
                                (wrld plist-worldp))
  :returns (mv (local-event "A @(tsee pseudo-event-formp).")
               (exported-event "A @(tsee pseudo-event-formp)."))
  :mode :program
  :short "Generate a theorem event from an applicability condition."
  :long
  (xdoc::topstring
   (xdoc::p
    "All the applicability conditions that must hold for the @(tsee defiso) call
     are turned into theorems exported from the @(tsee encapsulate).
     To keep the ACL2 history ``clean'',
     we generate the theorem in local form with a @(':by') hint
     (the references the local theorem name of the applicability condition;
     this name generally differs from
     the theorem name determined by @(':thm-names')),
     and in non-local, redundant form without hints."))
  (b* (((evmac-appcond appcond) appcond)
       (thm-name (cdr (assoc-eq appcond.name thm-names$)))
       (thm-formula (untranslate appcond.formula t wrld))
       (thm-hints
        `(("Goal" :by ,(cdr (assoc-eq appcond.name appcond-thm-names)))))
       (local-event `(local (defthmr ,thm-name ,thm-formula :hints ,thm-hints)))
       (exported-event `(defthmr ,thm-name ,thm-formula)))
    (mv local-event exported-event)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-appcond-thms ((appconds evmac-appcond-listp)
                                 (appcond-thm-names symbol-symbol-alistp)
                                 (thm-names$ symbol-symbol-alistp)
                                 (wrld plist-worldp))
  :returns (mv (local-events "A @(tsee pseudo-event-form-listp).")
               (exported-events "A @(tsee pseudo-event-form-listp)."))
  :mode :program
  :short "Lift @(tsee defiso-gen-appcond-thm) to
          lists of applicability conditions."
  (b* (((when (endp appconds)) (mv nil nil))
       ((mv local-event exported-event) (defiso-gen-appcond-thm
                                          (car appconds)
                                          appcond-thm-names
                                          thm-names$
                                          wrld))
       ((mv local-events exported-events) (defiso-gen-appcond-thms
                                            (cdr appconds)
                                            appcond-thm-names
                                            thm-names$
                                            wrld)))
    (mv (cons local-event local-events)
        (cons exported-event exported-events))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-nonappcond-thms ((doma$ pseudo-termfnp)
                                    (domb$ pseudo-termfnp)
                                    (alpha$ pseudo-termfnp)
                                    (beta$ pseudo-termfnp)
                                    (a1...an symbol-listp)
                                    (b1...bm symbol-listp)
                                    (unconditional$ booleanp)
                                    (thm-names$ symbol-symbol-alistp)
                                    (appcond-thm-names symbol-symbol-alistp)
                                    (wrld plist-worldp))
  :returns (mv (local-events "A @(tsee pseudo-event-form-listp).")
               (exported-events "A @(tsee pseudo-event-form-listp)."))
  :mode :program
  :short "Generate the theorems that are not applicability conditions."
  :long
  (xdoc::topstring
   (xdoc::p
    "Currently these are the two injectivity theorems.")
   (xdoc::p
    "We generate each theorem locally with hints,
     and also non-locally, redundantly without hints.
     This keeps the ACL2 world ``clean''.")
   (xdoc::p
    "We generate hints based on the proofs in the design notes.
     The @(':cases') hints correspond, in the proof in the design notes,
     to the inference step that applies @($\\beta$)
     to both sides of the equality @($\\alpha(a)=\\alpha(a')$)
     (in the proof of @(':alpha-injective')),
     or to the inference step that applies @($\\alpha$)
     to both sides of the equality @($\\beta(b)=\\beta(b')$)
     (in the proof of @(':beta-injective')).
     The hints for these proofs are the same
     whether @(':unconditional') is @('t') or @('nil')."))
  (b* ((aa1...aan (defiso-gen-var-aa/bb a1...an))
       (bb1...bbm (defiso-gen-var-aa/bb b1...bm))
       (alpha-injective-name (cdr (assoc-eq :alpha-injective thm-names$)))
       (beta-injective-name (cdr (assoc-eq :beta-injective thm-names$)))
       (alpha-injective-formula
        (b* ((antecedent (if unconditional$
                             *t*
                           (conjoin2 (apply-term doma$ a1...an)
                                     (apply-term doma$ aa1...aan))))
             (consequent `(equal (equal ,(apply-term alpha$ a1...an)
                                        ,(apply-term alpha$ aa1...aan))
                                 ,(conjoin-equalities a1...an aa1...aan)))
             (formula (implicate antecedent consequent)))
          (untranslate formula t wrld)))
       (beta-injective-formula
        (b* ((antecedent (if unconditional$
                             *t*
                           (conjoin2 (apply-term domb$ b1...bm)
                                     (apply-term domb$ bb1...bbm))))
             (consequent `(equal (equal ,(apply-term beta$ b1...bm)
                                        ,(apply-term beta$ bb1...bbm))
                                 ,(conjoin-equalities b1...bm bb1...bbm)))
             (formula (implicate antecedent consequent)))
          (untranslate formula t wrld)))
       (alpha-injective-hints
        (b* ((beta-of-alpha (cdr (assoc-eq :beta-of-alpha appcond-thm-names)))
             (beta-of-alpha-instance `(:instance ,beta-of-alpha
                                       ,@(alist-to-doublets
                                          (pairlis$ a1...an aa1...aan))))
             (m (len b1...bm))
             (cases-hints-formula
              (if (= m 1)
                  `(equal ,(apply-term* beta$
                                        (apply-term alpha$ a1...an))
                          ,(apply-term* beta$
                                        (apply-term alpha$ aa1...aan)))
                `(equal ,(apply-term beta$
                                     (make-mv-nth-calls
                                      (apply-term alpha$ a1...an)
                                      m))
                        ,(apply-term beta$
                                     (make-mv-nth-calls
                                      (apply-term alpha$ aa1...aan)
                                      m))))))
          `(("Goal"
             :in-theory nil
             :cases (,cases-hints-formula)
             :use (,beta-of-alpha ,beta-of-alpha-instance)))))
       (beta-injective-hints
        (b* ((alpha-of-beta (cdr (assoc-eq :alpha-of-beta appcond-thm-names)))
             (alpha-of-beta-instance `(:instance ,alpha-of-beta
                                       ,@(alist-to-doublets
                                          (pairlis$ b1...bm bb1...bbm))))
             (n (len a1...an))
             (cases-hints-formula
              (if (= n 1)
                  `(equal ,(apply-term* alpha$
                                        (apply-term beta$ b1...bm))
                          ,(apply-term* alpha$
                                        (apply-term beta$ bb1...bbm)))
                `(equal ,(apply-term alpha$
                                     (make-mv-nth-calls
                                      (apply-term beta$ b1...bm)
                                      n))
                        ,(apply-term alpha$
                                     (make-mv-nth-calls
                                      (apply-term beta$ bb1...bbm)
                                      n))))))
          `(("Goal"
             :in-theory nil
             :cases (,cases-hints-formula)
             :use (,alpha-of-beta ,alpha-of-beta-instance)))))
       (local-events
        (list `(local (defthmr ,alpha-injective-name
                        ,alpha-injective-formula
                        :hints ,alpha-injective-hints))
              `(local (defthmr ,beta-injective-name
                        ,beta-injective-formula
                        :hints ,beta-injective-hints))))
       (exported-events
        (list `(defthmr ,alpha-injective-name
                 ,alpha-injective-formula)
              `(defthmr ,beta-injective-name
                 ,beta-injective-formula))))
    (mv local-events exported-events)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-thms ((doma$ pseudo-termfnp)
                         (domb$ pseudo-termfnp)
                         (alpha$ pseudo-termfnp)
                         (beta$ pseudo-termfnp)
                         (a1...an symbol-listp)
                         (b1...bm symbol-listp)
                         (unconditional$ booleanp)
                         (thm-names$ symbol-symbol-alistp)
                         (appconds evmac-appcond-listp)
                         (appcond-thm-names symbol-symbol-alistp)
                         (wrld plist-worldp))
  :returns (mv (local-events "A @(tsee pseudo-event-form-listp).")
               (exported-events "A @(tsee pseudo-event-form-listp)."))
  :mode :program
  :short "Generate all the theorems."
  (b* (((mv appcond-local-events appcond-exported-events)
        (defiso-gen-appcond-thms appconds appcond-thm-names thm-names$ wrld))
       ((mv nonappcond-local-events nonappcond-exporte-events)
        (defiso-gen-nonappcond-thms
          doma$ domb$ alpha$ beta$ a1...an b1...bm
          unconditional$ thm-names$ appcond-thm-names wrld)))
    (mv (append appcond-local-events nonappcond-local-events)
        (append appcond-exported-events nonappcond-exporte-events))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-ext-table ((name$ symbolp)
                              (doma$ pseudo-termfnp)
                              (domb$ pseudo-termfnp)
                              (alpha$ pseudo-termfnp)
                              (beta$ pseudo-termfnp)
                              (unconditional$ booleanp)
                              (thm-names$ symbol-symbol-alistp)
                              (call$ pseudo-event-formp)
                              (expansion pseudo-event-formp))
  :returns (event pseudo-event-formp)
  :verify-guards nil
  :short "Generate the event that extends the @(tsee defiso) table."
  (b* ((alpha-image (cdr (assoc-eq :alpha-image thm-names$)))
       (beta-image (cdr (assoc-eq :beta-image thm-names$)))
       (beta-of-alpha (cdr (assoc-eq :beta-of-alpha thm-names$)))
       (alpha-of-beta (cdr (assoc-eq :alpha-of-beta thm-names$)))
       (alpha-injective (cdr (assoc-eq :alpha-injective thm-names$)))
       (beta-injective (cdr (assoc-eq :beta-injective thm-names$)))
       (doma-guard (cdr (assoc-eq :doma-guard thm-names$)))
       (domb-guard (cdr (assoc-eq :domb-guard thm-names$)))
       (alpha-guard (cdr (assoc-eq :alpha-guard thm-names$)))
       (beta-guard (cdr (assoc-eq :beta-guard thm-names$)))
       (info (make-defiso-info :call$ call$
                               :expansion expansion
                               :doma doma$
                               :domb domb$
                               :alpha alpha$
                               :beta beta$
                               :alpha-image alpha-image
                               :beta-image beta-image
                               :beta-of-alpha beta-of-alpha
                               :alpha-of-beta alpha-of-beta
                               :alpha-injective alpha-injective
                               :beta-injective beta-injective
                               :doma-guard doma-guard
                               :domb-guard domb-guard
                               :alpha-guard alpha-guard
                               :beta-guard beta-guard
                               :unconditional unconditional$)))
    `(table ,*defiso-table-name* ',name$ ',info)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-print-result ((thms pseudo-event-form-listp))
  :returns (cw-events pseudo-event-form-listp)
  :short "Generate the events that print the result."
  :long
  (xdoc::topstring-p
   "This refers to the @(':result') value of the @(':print') input.
    The result to print consists of the generated theorems.
    These theorems are printed only if
    @(':print') is @(':result') or @(':info') or @(':all').")
  (if (endp thms)
      nil
    (cons `(cw-event "~x0~|" ',(car thms))
          (defiso-gen-print-result (cdr thms)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-gen-everything ((name$ symbolp)
                               (doma$ pseudo-termfnp)
                               (domb$ pseudo-termfnp)
                               (alpha$ pseudo-termfnp)
                               (beta$ pseudo-termfnp)
                               (unconditional$ booleanp)
                               (guard-thms$ booleanp)
                               (thm-names$ symbol-symbol-alistp)
                               (hints$ symbol-truelist-alistp)
                               (print$ evmac-input-print-p)
                               (show-only$ booleanp)
                               (call pseudo-event-formp)
                               ctx
                               state)
  :returns (mv erp (event "A @(tsee pseudo-event-formp).") state)
  :mode :program
  :verify-guards nil
  :short "Generate the top-level event."
  :long
  (xdoc::topstring
   (xdoc::p
    "This is a @(tsee progn) that consists of
     the expansion of @(tsee defiso) (the @(tsee encapsulate)),
     followed by an event to extend the @(tsee defiso) table,
     optionally followed by events to print the generated theorems.
     The @(tsee progn) ends with @(':invisible')
     to avoid printing a return value.")
   (xdoc::p
    "The expansion starts with an implicitly local event to
     ensure logic mode.
     Other implicitly local event forms remove any default and override hints,
     to prevent such hints from sabotaging the generated proofs
     for the theorems that are not applicability conditions;
     this removal is done after proving the applicability conditions,
     in case their proofs rely on the default or override hints.")
   (xdoc::p
    "If @(':print') is @(':all'),
     the expansion is wrapped to show ACL2's output
     in response to the submitted events.
     If @(':print') is @(':info') or @(':all'),
     a blank line is printed just before the result, for visual separation;
     if @(':print') is @(':result'),
     the blank line is not printed.")
   (xdoc::p
    "If @(':show-only') is @('t'),
     the expansion is printed on the screen
     and not returned as part of the event to submit,
     which is in this case is just an @(':invisible') form.
     In this case, if @(':print') is @(':info') or @(':all'),
     a blank line is printed just before the @(tsee encapsulate),
     for visual separation."))
  (b* ((wrld (w state))
       (a1...an (defiso-gen-var-a1...an alpha$ wrld))
       (b1...bm (defiso-gen-var-b1...bm beta$ wrld))
       (appconds (defiso-gen-appconds
                   doma$ domb$ alpha$ beta$ a1...an b1...bm
                   unconditional$ guard-thms$ state))
       ((er (list appcond-events appcond-thm-names &))
        (evmac-appcond-theorems-no-extra-hints
         appconds hints$ nil print$ ctx state))
       ((mv local-thm-events exported-thm-events)
        (defiso-gen-thms
          doma$ domb$ alpha$ beta$ a1...an b1...bm
          unconditional$ thm-names$ appconds appcond-thm-names wrld))
       (expansion `(encapsulate
                     ()
                     (logic)
                     (set-ignore-ok t)
                     ,@appcond-events
                     (set-default-hints nil)
                     (set-override-hints nil)
                     ,@local-thm-events
                     ,@exported-thm-events))
       ((when show-only$)
        (if (member-eq print$ '(:info :all))
            (cw "~%~x0~|" expansion)
          (cw "~x0~|" expansion))
        (value '(value-triple :invisible)))
       (expansion+ (restore-output? (eq print$ :all) expansion))
       (call$ (defiso-filter-call call))
       (extend-table (defiso-gen-ext-table
                       name$
                       doma$
                       domb$
                       alpha$
                       beta$
                       unconditional$
                       thm-names$
                       call$
                       expansion))
       (print-result (and (member-eq print$ '(:result :info :all))
                          (append
                           (and (member-eq print$ '(:info :all))
                                '((cw-event "~%")))
                           (defiso-gen-print-result exported-thm-events)))))
    (value
     `(progn
        ,expansion+
        ,extend-table
        ,@print-result
        (value-triple :invisible)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-check-redundancy (name
                                 print
                                 show-only
                                 (call pseudo-event-formp)
                                 ctx
                                 state)
  :returns (mv erp
               (yes/no "A @(tsee booleanp).")
               state)
  :verify-guards nil
  :parents (defiso-implementation)
  :short "Check if a call to @(tsee defiso) is redundant."
  :long
  (xdoc::topstring
   (xdoc::p
    "If the @(tsee defiso) table has no entry for @('name'),
     we return @('nil'): the call is not redundant.")
   (xdoc::p
    "If the table has an entry for @('name') but the call differs
     (after removing any @(':print') and @(':show-only')),
     an error occurs.")
   (xdoc::p
    "If the call is redundant,
     we know that all the inputs except possibly @(':print') and @(':show-only')
     are valid
     (because they are the same as the ones of the recorded successful call);
     we validate these two inputs, for better error checking.
     If @(':show-only') is @('t'),
     we print the recorded expansion of the call.
     Unless @(':print') is @('nil'),
     we print a message saying that the call is redundant."))
  (b* ((table (table-alist *defiso-table-name* (w state)))
       (pair (assoc-equal name table))
       ((unless pair) (value nil))
       (info (cdr pair))
       (call$ (defiso-filter-call call))
       ((unless (equal call$ (defiso-info->call$ info)))
        (er-soft+ ctx t nil
                  "A different call to DEFISO with name ~x0 ~
                   has already been performed."
                  name))
       ((er &) (evmac-process-input-print print ctx state))
       ((er &) (evmac-process-input-show-only show-only ctx state))
       ((run-when show-only)
        (cw "~x0~|" (defiso-info->expansion info)))
       ((run-when print)
        (cw "~%The call ~x0 is redundant.~%" call)))
    (value t)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define defiso-fn (name
                   doma
                   domb
                   alpha
                   beta
                   unconditional
                   guard-thms
                   thm-names
                   hints
                   print
                   show-only
                   (call pseudo-event-formp)
                   ctx
                   state)
  :returns (mv erp
               (event "A @(tsee pseudo-event-formp).")
               state)
  :parents (defiso-implementation)
  :mode :program
  :short "Check redundancy,
          process the inputs,
          and generate the event to submit."
  (b* (((er redundant?) (defiso-check-redundancy
                          name print show-only call ctx state))
       ((when redundant?) (value '(value-triple :invisible)))
       ((er (list doma$
                  domb$
                  alpha$
                  beta$
                  thm-names$
                  hints$))
        (defiso-process-inputs
          name
          doma
          domb
          alpha
          beta
          unconditional
          guard-thms
          thm-names
          hints
          print
          show-only
          ctx
          state)))
    (defiso-gen-everything
      name
      doma$
      domb$
      alpha$
      beta$
      unconditional
      guard-thms
      thm-names$
      hints$
      print
      show-only
      call
      ctx
      state)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defsection defiso-macro-definition
  :parents (defiso-implementation)
  :short "Definition of the @(tsee defiso) macro."
  :long
  (xdoc::topstring
   (xdoc::p
    "Submit the event form generated by @(tsee defiso-fn).")
   (xdoc::@def "defiso"))
  (defmacro defiso (&whole
                    call
                    ;; mandatory inputs:
                    name
                    doma
                    domb
                    alpha
                    beta
                    ;; optional inputs:
                    &key
                    (unconditional 'nil)
                    (guard-thms 't)
                    (thm-names 'nil)
                    (hints 'nil)
                    (print ':result)
                    (show-only 'nil))
    `(make-event-terse (defiso-fn
                         ',name
                         ',doma
                         ',domb
                         ',alpha
                         ',beta
                         ',unconditional
                         ',guard-thms
                         ',thm-names
                         ',hints
                         ',print
                         ',show-only
                         ',call
                         (cons 'defiso ',name)
                         state)
                       :suppress-errors ,(not print))))
