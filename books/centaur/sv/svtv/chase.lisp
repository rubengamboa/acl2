; SV - Symbolic Vector Hardware Analysis Framework
; Copyright (C) 2014-2015 Centaur Technology
;
; Contact:
;   Centaur Technology Formal Verification Group
;   7600-C N. Capital of Texas Highway, Suite 300, Austin, TX 78731, USA.
;   http://www.centtech.com/
;
; License: (An MIT/X11-style license)
;
;   Permission is hereby granted, free of charge, to any person obtaining a
;   copy of this software and associated documentation files (the "Software"),
;   to deal in the Software without restriction, including without limitation
;   the rights to use, copy, modify, merge, publish, distribute, sublicense,
;   and/or sell copies of the Software, and to permit persons to whom the
;   Software is furnished to do so, subject to the following conditions:
;
;   The above copyright notice and this permission notice shall be included in
;   all copies or substantial portions of the Software.
;
;   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
;   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;   DEALINGS IN THE SOFTWARE.
;
; Original authors: Sol Swords <sswords@centtech.com>

(in-package "SV")

(include-book "debug")

;; This tool operates from an initialized DEBUGDATA stobj, as generated by
;; svtv-debug-core, or (without dumping a vcd) by svtv-debug-init followed by
;; svtv-debug-set-svtv.

;; It takes an input alist and expands it to an environment for each phase and
;; initial state so that we can evaluate a signal at a given phase.

;; Then we start from some given signal (an output/internal name or path and
;; phase).  We can evaluate that signal using svex-eval-svtv-phases.

(defprod svtv-evaldata
  ((nextstates svex-alist-p)
   (input-envs svex-envlist-p)
   (initst svex-env-p))
  :layout :tree)

(local (defthm svex-env-p-nth
         (implies (svex-envlist-p x)
                  (svex-env-p (nth n x)))))

(defines svex-eval-svtv-phases
  (define svex-eval-svtv-phases ((x svex-p)
                                 (phase natp)
                                 (data svtv-evaldata-p))
    :measure (acl2::nat-list-measure (list phase (svex-count x) 1))
    :returns (new-x 4vec-p)
    :verify-guards nil
    (b* ((x (svex-fix x)))
      (svex-case x
        :quote x.val
        :var (b* (((svtv-evaldata data))
                  (look (svex-fastlookup x.name data.nextstates))
                  ((when look)
                   ;; state var
                   (if (zp phase)
                       (svex-env-lookup x.name data.initst)
                     (svex-eval-svtv-phases look (1- phase) data))))
               ;; input var
               (b* ((env (nth phase (svex-envlist-fix data.input-envs))))
                 (svex-env-lookup x.name env)))
        :call (svex-eval-svtv-phases-call x phase data))))

  (define svex-eval-svtv-phases-call ((x svex-p)
                                      (phase natp)
                                      (data svtv-evaldata-p))
    :measure (acl2::nat-list-measure (list phase (svex-count x) 0))
    :returns (new-x 4vec-p)
    :guard (svex-case x :call)
    (b* (((unless (mbt (svex-case x :call))) (4vec-x))
         ((svex-call x)))
      (mbe :logic (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data))
           :exec
           (case x.fn
             ((? ?*)
              (b* (((unless (eql (len x.args) 3))
                    (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data)))
                   (test (3vec-fix (svex-eval-svtv-phases (first x.args) phase data)))
                   ((4vec test))
                   ((when (eql test.upper 0))
                    (svex-eval-svtv-phases (third x.args) phase data))
                   ((when (not (eql test.lower 0)))
                    (svex-eval-svtv-phases (second x.args) phase data))
                   (then (svex-eval-svtv-phases (second x.args) phase data))
                   (else (svex-eval-svtv-phases (third x.args) phase data)))
                (case x.fn
                  (? (4vec-? test then else))
                  (?* (4vec-?* test then else)))))
             (bit?
              (b* (((unless (eql (len x.args) 3))
                    (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data)))
                   (test (svex-eval-svtv-phases (first x.args) phase data))
                   ((when (eql test 0))
                    (svex-eval-svtv-phases (third x.args) phase data))
                   ((when (eql test -1))
                    (svex-eval-svtv-phases (second x.args) phase data)))
                (4vec-bit? test
                           (svex-eval-svtv-phases (second x.args) phase data)
                           (svex-eval-svtv-phases (third x.args) phase data))))
             (bitand
              (b* (((unless (eql (len x.args) 2))
                    (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data)))
                   (test (svex-eval-svtv-phases (first x.args) phase data))
                   ((when (eql test 0)) 0))
                (4vec-bitand test
                             (svex-eval-svtv-phases (second x.args) phase data))))
             (bitor
              (b* (((unless (eql (len x.args) 2))
                    (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data)))
                   (test (svex-eval-svtv-phases (first x.args) phase data))
                   ((when (eql test -1)) -1))
                (4vec-bitor test
                            (svex-eval-svtv-phases (second x.args) phase data))))
             (otherwise
              (svex-apply x.fn (svexlist-eval-svtv-phases x.args phase data)))))))

  (define svexlist-eval-svtv-phases ((x svexlist-p)
                                     (phase natp)
                                     (data svtv-evaldata-p))
    :measure (acl2::nat-list-measure (list phase (svexlist-count x) 1))
    :returns (new-x 4veclist-p)
    (if (atom x)
        nil
      (cons (svex-eval-svtv-phases (car x) phase data)
            (svexlist-eval-svtv-phases (cdr x) phase data))))
  ///

  
  (local (defthm consp-of-svexlist-eval
           (equal (consp (svexlist-eval x env))
                  (consp x))
           :hints (("goal" :expand ((svexlist-eval x env))))))

  (local (defthm upper-lower-of-3vec-fix
           (implies (and (3vec-p x)
                         (not (equal (4vec->lower x) 0)))
                    (not (equal (4vec->upper x) 0)))
           :hints(("Goal" :in-theory (enable 3vec-p)))))

  (local (defthm 4vec-?-cases
           (and (implies (equal (4vec->upper (3vec-fix test)) 0)
                         (equal (4vec-? test then else)
                                (4vec-fix else)))
                (implies (not (equal (4vec->lower (3vec-fix test)) 0))
                         (equal (4vec-? test then else)
                                (4vec-fix then))))
           :hints(("Goal" :in-theory (enable 4vec-? 3vec-?)))))

  (local (defthm 4vec-bit?-cases
           (and (implies (equal test 0)
                         (equal (4vec-bit? test then else)
                                (4vec-fix else)))
                (implies (equal test -1)
                         (equal (4vec-bit? test then else)
                                (4vec-fix then))))
           :hints(("Goal" :in-theory (enable 4vec-bit? 3vec-bit?)))))

  (local (defthm 4vec-?*-cases
           (and (implies (equal (4vec->upper (3vec-fix test)) 0)
                         (equal (4vec-?* test then else)
                                (4vec-fix else)))
                (implies (not (equal (4vec->lower (3vec-fix test)) 0))
                         (equal (4vec-?* test then else)
                                (4vec-fix then))))
           :hints(("Goal" :in-theory (enable 4vec-?* 3vec-?*)))))

  (local (defthm 4vec-bitand-case
           (implies (equal test 0)
                    (equal (4vec-bitand test x)
                           0))
           :hints(("Goal" :in-theory (enable 4vec-bitand 3vec-bitand)))))

  (local (defthm 4vec-bitor-case
           (implies (equal test -1)
                    (equal (4vec-bitor test x)
                           -1))
           :hints(("Goal" :in-theory (enable 4vec-bitor 3vec-bitor)))))


  (verify-guards svex-eval-svtv-phases
    :hints ((and stable-under-simplificationp
                 '(:in-theory (e/d (svex-apply len 4veclist-nth-safe nth)
                                   (svex-eval-svtv-phases))
                  :expand ((svexlist-eval-svtv-phases (svex-call->args x) phase data)
                           (svexlist-eval-svtv-phases (cdr (svex-call->args x)) phase data)
                           (svexlist-eval-svtv-phases (cddr (svex-call->args x)) phase data))))))
  (memoize 'svex-eval-svtv-phases-call)

  (defthm-svex-eval-svtv-phases-flag
    (defthm svex-eval-svtv-phases-correct
      (equal (svex-eval-svtv-phases x phase data)
             (b* (((svtv-evaldata data)))
               (svex-eval-unroll-multienv x phase data.nextstates
                                          data.input-envs
                                          data.initst)))
      :hints ('(:expand ((svex-eval-svtv-phases x phase data)
                         (:free (ins initst nextstates phase) (svex-eval-unroll-multienv x phase nextstates ins initst))))
              ;; (and stable-under-simplificationp
              ;;      '(:in-theory (enable svex-eval)))
              )
      :flag svex-eval-svtv-phases)
    (defthm svex-eval-svtv-phases-call-correct
      (implies (svex-case x :call)
               (equal (svex-eval-svtv-phases-call x phase data)
                      (b* (((svtv-evaldata data)))
                        (svex-eval-unroll-multienv x phase data.nextstates
                                                   data.input-envs
                                                   data.initst))))
      :hints ('(:expand ((svex-eval-svtv-phases-call x phase data)
                         (:free (ins initst nextstates phase) (svex-eval-unroll-multienv x phase nextstates ins initst))))
              (and stable-under-simplificationp
                   '(:in-theory (enable svex-eval))))
      :flag svex-eval-svtv-phases-call)
    (defthm svexlist-eval-svtv-phases-correct
      (equal (svexlist-eval-svtv-phases x phase data)
             (b* (((svtv-evaldata data)))
               (svexlist-eval-unroll-multienv x phase data.nextstates
                                              data.input-envs
                                              data.initst)))
      :hints ('(:expand ((svexlist-eval-svtv-phases x phase data)
                         (:free (nextstates ins initst) (svexlist-eval-unroll-multienv x phase nextstates ins initst)))))
      :flag svexlist-eval-svtv-phases))

  (deffixequiv-mutual svex-eval-svtv-phases))


(define svex-alistlist-eval ((x svex-alistlist-p)
                             (env svex-env-p))
  :returns (envs svex-envlist-p)
  (if (atom x)
      nil
    (cons (svex-alist-eval (car x) env)
          (svex-alistlist-eval (cdr x) env))))

(define make-fast-alists (x)
  :enabled t
  (mbe :logic x
       :exec (if (atom x)
                 x
               (cons (make-fast-alist (car x))
                     (make-fast-alists (cdr x))))))

(define svtv-chase-inalist-to-evaldata ((inalist svex-env-p)
                                        &key
                                        (debugdata 'debugdata)
                                        )
  :returns (evaldata svtv-evaldata-p)
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable debugdatap)
                       :do-not-induct t)))
  :guard-debug t
  (b* (((debugdata debugdata))

       (ins (svtv-expand-lines debugdata.ins debugdata.nphases))
       ((mv ovlines ?ovs) (svtv-lines->overrides debugdata.overrides 0))
       (states (svex-alist-keys debugdata.nextstates))

       (in-vars (acl2::hons-set-diff (svexlist-collect-vars
                                      (append (svex-alist-vals debugdata.updates)
                                              (svex-alist-vals debugdata.nextstates)))
                                     (append (svex-alist-keys debugdata.updates)
                                             states)))

       (in-alists (if (eql 0 debugdata.nphases)
                      nil
                    (svtv-allphases-inputs 0 debugdata.nphases ins ovlines in-vars)))
       (in-envs (svex-alistlist-eval in-alists inalist))
       (- (clear-memoize-table 'svex-eval))
       (initst (make-fast-alist (pairlis$ states
                                          (replicate (len states) (4vec-x))))))
    (make-svtv-evaldata :nextstates (make-fast-alist debugdata.nextstates)
                        :input-envs (make-fast-alists in-envs)
                        :initst (make-fast-alist initst))))


;; There are basically three types of signals/svex variables used here:
;;  - If V is a key of nextstates/delays, then it is a previous state signal.
;;  - If V is a key of updates/assigns, then it is an internal signal.
;;  - If V appears in an expression (value) of updates or nextstates but is not
;;  a key of either one, then it is a primary input.

;;    A previous state signal cannot also be an internal signal (a key of
;;    nextstates cannot also be a key of updates).  But each V that is a
;;    previous state/key of updates is also a key of delays, and the
;;    corresponding value in delays is an internal signal or primary input that
;;    is also the nextstate of V.

;; The keys of nextstates should be the same as those of delays.  The keys of
;; updates should be the same as those of assigns.


;; We want to support exploring the design by walking through following
;; dependencies back to drivers. Generally we'll have a stack starting from
;; some signal and going back though its drivers (across phases).

;; The current position will be tracked as a variable, phase, right-shift, and
;; mask.  The mask is relative to the right-shift, so the caremask for the
;; whole variable is mask << right-shift.

;; We'll find dependencies of a variable modulo the caremask, and the resulting
;; dependency variables will be reported along with their caremasks.
;; Internally we'll use right-shifts and masks, but when we print things out to
;; the user we'll want to translate back to relative indices.  E.g. if a
;; variable is declared as x[10:2] and we have a rightshift of 3 and mask
;; #b101, we'll show the range as x[7:5].



(define svtv-chase-eval ((var svar-p)
                         (phase natp)
                         &key
                         (debugdata 'debugdata)
                         ((evaldata svtv-evaldata-p) 'evaldata))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable debugdatap))))
  :returns (val 4vec-p)
  (b* (((debugdata debugdata))
       (phase (lnfix phase))
       (var (svar-fix var))
       (svex (svex-fastlookup var debugdata.updates))
       ((when svex)
        (svex-eval-svtv-phases svex phase evaldata)))
    (svex-eval-svtv-phases (svex-var var) phase evaldata)))


(define svtv-chase-evallist ((vars svarlist-p)
                             (phase natp)
                             &key
                             (debugdata 'debugdata)
                             ((evaldata svtv-evaldata-p) 'evaldata))
  :returns (vals 4veclist-p)
  (if (atom vars)
      nil
    (cons (svtv-chase-eval (car vars) phase)
          (svtv-chase-evallist (cdr vars) phase)))
  ///
  (defret len-of-<fn>
    (equal (len vals) (len vars))))
       


(define svex-mask-alist-to-4vmask-alist ((x svex-mask-alist-p))
  :returns (new-x 4vmask-alist-p)
  (if (atom x)
      nil
    (if (and (mbt (and (consp (car x)) (svex-p (caar x))))
             (svex-case (caar x) :var)
             (not (sparseint-equal (cdar x) 0)))
        (cons (cons (svex-var->name (caar x))
                    (sparseint-fix (cdar x)))
              (svex-mask-alist-to-4vmask-alist (cdr x)))
      (svex-mask-alist-to-4vmask-alist (cdr x)))))


(local (defthm svarlist-p-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (svarlist-p (alist-keys x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))


;; (local
;;  (defsection svarlist-addr-p-of-svexlist-compute-masks
;;    (defret member-vars-of-svex-args-apply-masks
;;      (implies (and (not (member v (svexlist-vars args)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svex-args-apply-masks)))
;;      :fn svex-args-apply-masks)

;;    (defret member-vars-of-svexlist-compute-masks
;;      (implies (and (not (member v (svexlist-vars x)))
;;                    (not (member v (svexlist-vars (svex-mask-alist-keys mask-al)))))
;;               (not (member v (svexlist-vars (svex-mask-alist-keys mask-al1)))))
;;      :hints(("Goal" :in-theory (enable svexlist-compute-masks)))
;;      :fn svexlist-compute-masks)

;;    (defret member-alist-keys-of-svex-mask-alist-to-4vmask-alist
;;      (implies (not (member v (svexlist-vars (svex-mask-alist-keys x))))
;;               (not (member v (alist-keys new-x))))
;;      :hints(("Goal" :in-theory (enable svex-mask-alist-to-4vmask-alist
;;                                        svex-mask-alist-keys
;;                                        alist-keys)))
;;      :fn svex-mask-alist-to-4vmask-alist)))


(local (defthm svex-mask-alist-p-of-fast-alist-fork
         (implies (and (svex-mask-alist-p x)
                       (svex-mask-alist-p y))
                  (svex-mask-alist-p (fast-alist-fork x y)))))

(local (defthm atom-of-cdr-last
         (not (consp (cdr (last x))))
         :rule-classes :type-prescription))

(define svexlist-compute-masks-with-eval ((x svexlist-p)
                                          (mask-al svex-mask-alist-p)
                                          (env svex-env-p))
  :returns (mask-al1 svex-mask-alist-p)
  (b* (((when (atom x))
        (mbe :logic (svex-mask-alist-fix mask-al)
             :exec mask-al))
       (first (car x))
       ((when (not (eq (svex-kind first) :call)))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (mask (svex-mask-lookup first mask-al))
       ((when (sparseint-equal mask 0))
        (svexlist-compute-masks-with-eval (cdr x) mask-al env))
       (args (svex-call->args first))
       (argvals (4veclist-quote (svexlist-eval args env)))
       (argmasks (svex-argmasks mask
                                (svex-call->fn first)
                                argvals))
       (mask-al (svex-args-apply-masks args argmasks mask-al)))
    (svexlist-compute-masks-with-eval (cdr x) mask-al env)))

(define svtv-chase-expr-deps ((expr svex-p)
                              (phase natp)
                              (rsh natp)
                              (mask 4vmask-p)
                              (smartp)
                              &key
                              (debugdata 'debugdata)
                              ((evaldata svtv-evaldata-p) 'evaldata))
  :returns (deps svex-mask-alist-p)
  (b* (((mv toposort al) (svex-toposort expr nil nil))
       (- (fast-alist-free al))
       (start-mask-al (svex-mask-acons expr (sparseint-ash mask rsh) nil))
       ((unless smartp)
        (fast-alist-free
         (fast-alist-clean
          (svexlist-compute-masks toposort start-mask-al))))
       (vars (svex-collect-vars expr))
       (env (make-fast-alist (pairlis$ vars (svtv-chase-evallist vars phase))))
       (mask-al (fast-alist-free
                 (fast-alist-clean
                  (svexlist-compute-masks-with-eval
                   toposort (svex-mask-acons expr (sparseint-ash mask rsh) nil)
                   env)))))
    (fast-alist-free env)
    mask-al))
       


(define svtv-chase-deps ((var svar-p)
                         (phase natp)
                         (rsh natp)
                         (mask 4vmask-p)
                         &key
                         (smartp 'smartp)
                         (debugdata 'debugdata)
                         ((evaldata svtv-evaldata-p) 'evaldata))
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable debugdatap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (expr svex-p))
  (b* (((debugdata debugdata))
       (phase (lnfix phase))
       (var (svar-fix var))
       (type
        (b* ((svex (svex-fastlookup var debugdata.updates))
             ((when svex)
              :update)
             (prev-var-look (hons-get var (svar-map-fix debugdata.delays)))
             ((when prev-var-look)
              (if (eql phase 0)
                  :initst
                :prevst)))
          :input))

       ((when (or (eq type :input)
                  (eq type :initst)))
        (mv type nil (svex-var var)))

       ((when (eq type :prevst))
        (mv type (list (cons var (sparseint-ash mask rsh)))
            (svex-var var)))

       (expr (svex-fastlookup var debugdata.override-assigns))

       ((unless expr)
        (mv :error nil (svex-x)))

       (mask-al (svtv-chase-expr-deps expr phase rsh mask smartp))
       
       (vars (svex-mask-alist-to-4vmask-alist mask-al)))
    (mv type vars expr))
  ///
  ;; (local (defthm svar-addr-p-lookup-in-svar-map
  ;;          (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                        (hons-assoc-equal k (svar-map-fix x)))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k (svar-map-fix x)))))
  ;;          :hints(("Goal" :in-theory (e/d (svar-map-vars svar-map-fix)
  ;;                                         (hons-assoc-equal-of-svar-map-fix))
  ;;                  :induct (svar-map-vars x)))
  ;;          :rule-classes
  ;;          ((:rewrite :corollary
  ;;            (implies (And (svarlist-addr-p (svar-map-vars x))
  ;;                          (svar-p k)
  ;;                          (hons-assoc-equal k x))
  ;;                   (svar-addr-p (cdr (hons-assoc-equal k x))))))))

  ;; (local (defthm member-svex-mask-alist-keys-of-fast-alist-fork
  ;;          (implies (and (not (member v (svexlist-vars (svex-mask-alist-keys x))))
  ;;                        (not (member v (svexlist-vars (svex-mask-alist-keys y)))))
  ;;                   (not (member v (svexlist-vars (svex-mask-alist-keys (fast-alist-fork x y))))))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (local (defthm svex-mask-alist-keys-of-atom
  ;;          (implies (atom x)
  ;;                   (equal (svex-mask-alist-keys x) nil))
  ;;          :hints(("Goal" :in-theory (enable svex-mask-alist-keys)))))

  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )

(define svtv-chase-var-name/range ((var svar-p)
                                   (rsh natp)
                                   (mask 4vmask-p)
                                   (modidx natp)
                                   &key
                                   ((moddb moddb-ok) 'moddb))
  :returns (name-range-msg)
  :guard (< modidx (moddb->nmods moddb))
  (b* (((svar var))
       (rsh (lnfix rsh))
       (mask (sparseint-val mask))
       (maskwidth (and (<= 0 mask)
                       (integer-length mask)))
       ((unless (address-p var.name))
        (b* (((when maskwidth)
              (msg "~x0[~x1:~x2]" var.name (1- maskwidth) rsh)))
          (cw! "Warning: For non-address variable ~x0, caremask was ~
                unbounded!~%" var)
          (msg "~x0[??:~x1]" var.name rsh)))
       (path (address->path var.name))
       (name (path->string-top path))
       ((mv err wire & &) (moddb-path->wireidx/decl path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top path) err)
        (b* (((when maskwidth)
              (msg "~s0[~x1:~x2]" name (1- maskwidth) rsh)))
          (cw! "Warning: For unrecognized wire ~s0, caremask was unbounded!~%" name)
          (msg "~s0[??:~x1]" (path->string-top path) rsh)))
       ((wire wire))
       (width (if maskwidth
                  (min (+ rsh (max 1 maskwidth)) wire.width)
                wire.width))
       (lsb (if wire.revp
                (- (+ wire.low-idx (- wire.width 1)) rsh)
              (+ rsh wire.low-idx)))
       (msb (if wire.revp
                (- lsb (- width 1))
              (+ lsb (- width 1)))))
    (msg "~s0[~x1:~x2]" name msb lsb)))


(define svtv-chase-print-signal ((index acl2::maybe-natp)
                                 (var svar-p)
                                 (rsh natp)
                                 (mask 4vmask-p)
                                 (val 4vec-p "Value for the whole variable.")
                                 (modidx natp)
                                 &key
                                 ((moddb moddb-ok) 'moddb))
  :guard (and ;; (svar-addr-p var)
              (< modidx (moddb->nmods moddb)))
  :prepwork ((local (in-theory (e/d (svar-addr-p)
                                    (str::hexify max)))))
  (b* ((name/range (svtv-chase-var-name/range var rsh mask modidx))
       (mask (sparseint-val mask))
       (masked-val (4vec-bitand (4vec-shift-core (- (lnfix rsh)) val)
                                (2vec mask)))
       (delay (svar->delay var))
       (delay-msg (if (eql delay 0)
                      ""
                    (msg " (delay ~x0)" delay))))
  (if (2vec-p masked-val)
      (b* ((val (str::hexify (2vec->val masked-val)))
           (mask (str::hexify mask))
           (vl (length val))
           (ml (length mask))
           (maxl (max vl ml))
           (pad-v (- maxl vl))
           (pad-m (- maxl ml)))
        
        (cw! "~@0 ~@1~@2: ~t3~_4~s5~%"
             (if index (msg "~x0." index) "")
             name/range
             delay-msg
             30
             pad-v
             val)
        (cw! " caremask:~t0~_1~s2~%"
             30
             pad-m
             mask))
    (b* (((4vec val) masked-val)
         (upper (str::hexify val.upper))
         (lower (str::hexify val.lower))
         (xmask (str::hexify (logxor val.upper val.lower)))
         (mask  (str::hexify mask))
         ;; padding for right-aligning the three values
         (ul (length upper)) (ll (length lower)) (xl (length xmask)) (ml (length mask))
         (maxl (max ml (max xl (max ul ll))))
         (pad-u (- maxl ul))
         (pad-l (- maxl ll))
         (pad-x (- maxl xl))
         (pad-m (- maxl ml)))
      (cw! "~@0 ~@1~@2: ~t3(  ~_4~s5~%"
           (if index (msg "~x0." index) "")
           name/range
           delay-msg
           30 pad-u upper)
      (cw! "~t0 . ~_1~s2 )~%" 30 pad-l lower)
      (cw! " non-Boolean portion: ~t0   ~_1~s2~%" 30 pad-x xmask)
      (cw! " caremask:            ~t0   ~_1~s2~%" 30 pad-m mask)))))

(local (defthm len-equal-0
         (equal (equal (len x) 0)
                (not (consp x)))))

(define svtv-chase-print-signals ((index natp)
                                  (vars 4vmask-alist-p)
                                  (vals 4veclist-p)
                                  (modidx natp)
                                  &key
                                  ((moddb moddb-ok) 'moddb))
  :guard (and (eql (len vars) (len vals))
              ;; (svarlist-addr-p (alist-keys vars))
              (< modidx (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (enable alist-keys)))
  (if (atom vars)
      nil
    (if (mbt (consp (car vars)))
        (prog2$ (svtv-chase-print-signal (lnfix index)
                                         (caar vars)
                                         0 (cdar vars)
                                         (car vals)
                                         modidx)
                (svtv-chase-print-signals (1+ (lnfix index)) (cdr vars) (cdr vals) modidx))
      (svtv-chase-print-signals (1+ (lnfix index)) (cdr vars) (cdr vals) modidx))))

      
                     
         
(local (defthm len-alist-keys-when-4vmask-alist-p
         (implies (4vmask-alist-p x)
                  (equal (len (alist-keys x))
                         (len x)))
         :hints(("Goal" :in-theory (enable alist-keys)))))

(define svtv-chase-normalize-var/phase ((var svar-p)
                                        (phase natp))
  :returns (mv (new-var svar-p)
               (new-phase natp :rule-classes :type-prescription))
  (b* (((svar var))
       ((when (eql 0 var.delay))
        (mv (svar-fix var) (lnfix phase)))
       ((when (<= var.delay (lnfix phase)))
        (mv (change-svar var :delay 0) (- (lnfix phase) var.delay))))
    (mv (change-svar var :delay (- var.delay (lnfix phase))) 0))
  ///
  ;; (defret svar-addr-p-of-<fn>
  ;;   (implies (svar-addr-p var)
  ;;            (svar-addr-p new-var))
  ;;   :hints(("Goal" :in-theory (enable svar-addr-p))))
  )
    
(local (in-theory (disable nth update-nth)))


(define svtv-chase-signal ((var svar-p)
                           (phase natp)
                           (rsh natp)
                           (mask 4vmask-p)
                           &key
                           (smartp 'smartp)
                           (debugdata 'debugdata)
                           ((moddb moddb-ok) 'moddb)
                           ((evaldata svtv-evaldata-p) 'evaldata))
  :guard (and ;; (svar-addr-p var)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb)))
  :guard-hints ((And stable-under-simplificationp
                     '(:in-theory (enable debugdatap))))
  :returns (mv (type symbolp :rule-classes :type-prescription)
               (vars 4vmask-alist-p)
               (expr svex-p))
  (b* (((mv var phase) (svtv-chase-normalize-var/phase var phase))
       ((4vec val) (svtv-chase-eval var phase))
       (modidx (debugdata->modidx debugdata))
       (- (svtv-chase-print-signal nil var rsh mask val modidx)
          (cw! "(Phase ~x0.)~%" phase))
       ((mv type vars expr)
        (svtv-chase-deps var phase rsh mask)))
    (b* (((when (eq type :error))
          (cw! "Error! Somehow this signal wasn't what we expected.~%"))
         ((when (eq type :input))
          (cw! "Primary input.~%"))
         ((when (eq type :initst))
          (cw! "Initial state.~%"))
         (vals (svtv-chase-evallist (alist-keys vars) phase))
         ((when (eq type :prevst))
          (cw! "Previous state var.~%")
          (svtv-chase-print-signals 0 vars vals modidx)))
      (cw! "Internal signal; dependencies:~%")
      (svtv-chase-print-signals 0 vars vals modidx))
    (mv type vars expr))
  ///
  ;; (defret svarlist-addr-p-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (alist-keys vars)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))

  

  ;; (defret svarlist-addr-p-expr-of-<fn>
  ;;   (implies (and (svar-addr-p var)
  ;;                 (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
  ;;                 (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata))))
  ;;            (svarlist-addr-p (svex-vars expr)))
  ;;   :hints(("Goal" :in-theory (enable alist-keys))))
  )

;; (define svar-addr-p! (x)
;;   :enabled t
;;   (and (svar-p x)
;;        (svar-addr-p x)))

;; (define 4vmask-alist-addr-p! (x)
;;   :enabled t
;;   (and (4vmask-alist-p x)
;;        (svarlist-addr-p (alist-keys x))))

;; (define svex-addr-p! (x)
;;   :enabled t
;;   (and (svex-p x)
;;        (svarlist-addr-p (svex-vars x))))

(defprod chase-position
  ((path path-p)
   (phase natp :rule-classes :type-prescription)
   (rsh natp :rule-classes :type-prescription)
   (mask 4vmask-p)))

;; (define chase-position-addr-p ((x chase-position-p))
;;   (svar-addr-p (chase-position->var x)))

;; (define chase-position-addr-p! (x)
;;   :enabled t
;;   (and (chase-position-p x)
;;        (chase-position-addr-p x)))

(deflist chase-stack :elt-type chase-position :true-listp t)

;; (define chase-stack-addr-p ((x chase-stack-p))
;;   (if (atom x)
;;       t
;;     (and (chase-position-addr-p (car x))
;;          (chase-stack-addr-p (cdr x)))))

;; (define chase-stack-addr-p! (x)
;;   :enabled t
;;   (and (chase-stack-p x)
;;        (chase-stack-addr-p x)))
       

;; (make-event
;;  `(defstobj svtv-chase-data
;;     (chase-stack :type (satisfies chase-stack-addr-p!) :initially nil)
;;     (chase-type :type symbol)
;;     (chase-vars :type (satisfies 4vmask-alist-addr-p!))
;;     (chase-expr :type (satisfies svex-addr-p!) :initially ,(svex-x))
;;     (chase-new-phase :type (integer 0 *) :initially 0)
;;     (chase-evaldata :type (satisfies svtv-evaldata-p) :initially ,(make-svtv-evaldata))))

(make-event
 `(defstobj svtv-chase-data
    (chase-stack :type (satisfies chase-stack-p) :initially nil)
    (chase-type :type symbol)
    (chase-vars :type (satisfies 4vmask-alist-p))
    (chase-expr :type (satisfies svex-p) :initially ,(svex-x))
    ;; (chase-new-phase :type (integer 0 *) :initially 0)
    (chase-evaldata :type (satisfies svtv-evaldata-p) :initially ,(make-svtv-evaldata))
    (chase-smartp :initially t)))

(define svtv-chase-signal-data ((pos chase-position-p)
                                &key
                                (debugdata 'debugdata)
                                ((moddb moddb-ok) 'moddb)
                                (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (enable debugdatap
                                           ;; chase-position-addr-p
                                           ;; chase-stack-addr-p
                                           )))
  :returns (new-svtv-chase-data)
  (b* (((chase-position pos))
       ((mv type vars expr)
        (svtv-chase-signal (make-svar :name (make-address :path pos.path))
                           pos.phase pos.rsh pos.mask
                           :smartp (chase-smartp svtv-chase-data)
                           :evaldata (chase-evaldata svtv-chase-data)
                           :debugdata debugdata))
       ((when (eq type :error))
        (cw! "[Error -- discrepancy between stored updates and assignments!]~%")
        svtv-chase-data)
       (svtv-chase-data (update-chase-stack (cons pos (chase-stack svtv-chase-data))
                                            svtv-chase-data))
       (svtv-chase-data (update-chase-type type svtv-chase-data))
       (svtv-chase-data (update-chase-vars vars svtv-chase-data))
       (svtv-chase-data (update-chase-expr expr svtv-chase-data))
       ;; (svtv-chase-data (update-chase-new-phase new-phase svtv-chase-data))
       )
    svtv-chase-data))


(define svtv-chase-range ((pos chase-position-p)
                          (msb integerp)
                          (lsb integerp)
                          &key
                          (debugdata 'debugdata)
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (chase-position-addr-p pos)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb)))
  :guard-hints (("goal" :in-theory (enable ;; chase-position-addr-p
                                           ;; svar-addr-p
                                           debugdatap)))
  :returns (new-svtv-chase-data)
  :prepwork ((local (in-theory (disable logmask not))))
  (b* ((modidx (debugdata->modidx debugdata))
       ((chase-position pos))
       ;; (path (address->path (svar->name pos.var)))
       ((mv err wire & &) (moddb-path->wireidx/decl pos.path modidx moddb))
       ((when err)
        (cw! "[ERROR finding wire ~s0]: ~@1~%" (path->string-top pos.path) err)
        svtv-chase-data)
       ((wire wire))
       (msb (lifix msb))
       (lsb (lifix lsb))
       (wire-lsb (if wire.revp
                     (+ wire.low-idx (- wire.width 1))
                   wire.low-idx))
       (wire-msb (if wire.revp
                     wire.low-idx
                   (+ wire.low-idx (- wire.width 1))))
       ((unless (if wire.revp
                    (and (<= wire-msb msb) (<= msb lsb) (<= lsb wire-lsb))
                  (and (<= wire-lsb lsb) (<= lsb msb) (<= msb wire-msb))))
        (cw! "Bad range for ~s0: declared range is [~x1:~x2]~%"
             (path->string-top pos.path) wire-msb wire-lsb)
        svtv-chase-data)
       (width (if wire.revp
                  (+ 1 (- lsb msb))
                (+ 1 (- msb lsb))))
       (rsh (if wire.revp (- wire-lsb lsb) (- lsb wire-lsb)))
       (mask (logmask width))
       (new-pos (change-chase-position pos
                                       :rsh rsh
                                       :mask (int-to-sparseint mask))))
    (svtv-chase-signal-data new-pos)))

;; (local
;;  (defsection lhs-addr-p-of-svtv-wire->lhs

;;    (defret lhs-addr-p-of-svtv-1wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-1wire->lhs
;;                                        )))
;;      :fn svtv-1wire->lhs)

;;    (local (defthm member-lhs-vars-of-append
;;             (implies (and (not (member v (lhs-vars a)))
;;                           (not (member v (lhs-vars b))))
;;                      (not (member v (lhs-vars (append a b )))))
;;             :hints(("Goal" :in-theory (enable lhs-vars)))))

;;    (defret lhs-addr-p-of-svtv-concat->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-concat->lhs
;;                                        )))
;;      :fn svtv-concat->lhs)

;;    (defret lhs-addr-p-of-svtv-wire->lhs
;;      (implies (svarlist-addr-p (aliases-vars aliases))
;;               (svarlist-addr-p (lhs-vars lhs)))
;;      :hints(("Goal" :in-theory (enable svtv-wire->lhs)))
;;      :fn svtv-wire->lhs)))


;; (local (include-book "centaur/bitops/ihsext-basics" :dir :system
(local (in-theory (disable logmask)))

(define svtv-chase-goto ((str stringp)
                         (phase natp)
                         &key
                         (debugdata 'debugdata)
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data))
  :guard (and ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (debugdata->modidx debugdata) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints (("goal" :in-theory (enable svtv-mod-alias-guard
                                           ;; chase-position-addr-p
                                           debugdatap)
                 :do-not-induct t))
  ;; :prepwork ((local (defthm svar-addr-p-of-lhatom-var->name
  ;;                     (implies (and (lhatom-case x :var)
  ;;                                   (svarlist-addr-p (lhatom-vars x)))
  ;;                              (svar-addr-p (lhatom-var->name x)))
  ;;                     :hints(("Goal" :in-theory (enable lhatom-vars)))))
  ;;            (local (defthm member-vars-of-lhrange->atom
  ;;                     (implies (and (not (member v (lhs-vars x)))
  ;;                                   (consp x))
  ;;                              (not (member v (lhatom-vars (lhrange->atom (car x))))))
  ;;                     :hints(("Goal" :in-theory (enable lhs-vars)))))
  ;;            (local (in-theory (disable lhs-vars-when-consp))))
  :guard-debug t
  :returns (new-svtv-chase-data)
  (b* (((mv err lhs) (svtv-wire->lhs str (debugdata->modidx debugdata) moddb aliases))
       ((when err)
        (cw! "Error interpreting name: ~s0~%" str)
        svtv-chase-data)
       ((when (atom lhs))
        (cw! "Error interpreting name: ~s0~%" str)
        svtv-chase-data)
       ((when (consp (cdr lhs)))
        (cw! "Error interpreting name: ~s0 was a concatenation~%" str)
        svtv-chase-data)
       ((lhrange lhrange) (car lhs))
       ((unless (lhatom-case lhrange.atom :var))
        (cw! "Error interpreting name: ~s0 had no variable component~%" str)
        svtv-chase-data)
       ((lhatom-var lhrange.atom))
       ((svar lhrange.atom.name))
       ((unless (address-p lhrange.atom.name.name))
        (cw! "Error interpreting name: ~s0 produced a variable that was not an address~%" str)
        svtv-chase-data)
       (pos (make-chase-position :path (address->path lhrange.atom.name.name)
                                 :phase phase
                                 :rsh lhrange.atom.rsh
                                 :mask (int-to-sparseint (logmask lhrange.w)))))
    (svtv-chase-signal-data pos)))
       

(define svtv-chase-print (&key
                          (debugdata 'debugdata)
                          ((moddb moddb-ok) 'moddb)
                          (svtv-chase-data 'svtv-chase-data))
  :guard (and (< (debugdata->modidx debugdata) (moddb->nmods moddb)))
  :returns new-svtv-chase-data
  :guard-hints (("goal" :in-theory (enable debugdatap)
                 :do-not-induct t)
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                )
  (b* ((stack (chase-stack svtv-chase-data))
       ((unless (consp stack))
        (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
        svtv-chase-data)
       (pos (car stack))
       (svtv-chase-data (update-chase-stack (cdr stack) svtv-chase-data))
       (svtv-chase-data (svtv-chase-signal-data pos)))
    svtv-chase-data)
  ///
  (defmacro svtv-chase-print! (&rest args)
    `(b* ((svtv-chase-data (svtv-chase-print . ,args)))
       (mv nil svtv-chase-data state))))

(defconst *chase-usage*
  "
What you can enter at the SVTV-CHASE prompt:

 ?                  prints this help message

 X                  Exit the chase read-eval-print loop.

 P                  prints the current state, including the next signal choices

 (G \"path\" phase) Go to the signal named by the given path at the given phase
 (R MSB LSB)        Select the given MSB:LSB range of the current signal

 Natural number     Select the given choice of next signal
 B                  Go back to the previous signal on the stack.

 EXPR               Print the assignment for the current signal.
 (EXPR N)           Print the assignment expression, limiting nesting depth to N.

 SMARTP             Toggle data-aware dependency reduction feature
                    (reduces the number of irrelevant signals listed).
                    On by default.

 (EV form)          Evaluates form using simple-translate-and-eval 
                    and prints the result.  You need to set up an attachment
                    to do this, which you can do by running
                    (sv::setup-ev-for-chase) in the ACL2 loop.  You can undo this
                    with (sv::unsetup-ev-for-chase).
")

(defmacro setup-ev-for-chase ()
  '(progn
     (defttag trans)
     (defattach (simple-translate-and-eval-logic acl2::simple-translate-and-eval-cmp)
       :skip-checks t)))

(defmacro unsetup-ev-for-chase ()
  '(progn
     (defttag nil)
     (defattach (simple-translate-and-eval-logic nil))))

;; (local (defthm chase-position-addr-p-car-when-chase-stack-addr-p
;;          (implies (and (chase-stack-addr-p x)
;;                        (consp x))
;;                   (chase-position-addr-p (car x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))

;; (local (defthm chase-stack-addr-p-cdr-when-chase-stack-addr-p
;;          (implies (chase-stack-addr-p x)
;;                   (chase-stack-addr-p (cdr x)))
;;          :hints(("Goal" :in-theory (enable chase-stack-addr-p)))))


(local (defthm nth-when-4vmask-alist-p
         (implies (and (4vmask-alist-p x)
                       (< (nfix n) (len x)))
                  (and (consp (nth n x))
                       (svar-p (car (nth n x)))
                       (sparseint-p (cdr (nth n x)))))
         :hints(("Goal" :in-theory (enable nth)))))

;; (local (defthm nth-svar-addr-p-when-4vmask-alist-p
;;          (implies (and (4vmask-alist-p x)
;;                        (svarlist-addr-p (alist-keys x))
;;                        (< (nfix n) (len x)))
;;                   (svar-addr-p (car (nth n x))))
;;          :hints(("Goal" :in-theory (enable nth alist-keys)))))

(local (in-theory (disable read-object
                           open-input-channel-p1
                           member)))

(include-book "std/io/file-measure" :dir :system)
(local (include-book "std/io/open-channels" :dir :system))
(local (in-theory (disable file-measure)))

(verify-termination evisc-tuple)
(verify-guards evisc-tuple)


(encapsulate
  (((simple-translate-and-eval-logic
     * * * * * * state * * *) => (mv * *)
    :formals (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
    :guard t))
  (set-ignore-ok t)
  (set-irrelevant-formals-ok t)
  (local (defun simple-translate-and-eval-logic (x alist ok-stobj-names msg ctx wrld state aok safe-mode gc-off)
           (declare (xargs :stobjs state))
           (mv nil nil))))


(local (in-theory (disable w)))

(local (defthm w-of-read-object
         (equal (w (mv-nth 2 (read-object channel state)))
                (w state))
         :hints(("Goal" :in-theory (enable w read-object)))))

(define svtv-chase-rep (&key
                        (debugdata 'debugdata)
                        ((moddb moddb-ok) 'moddb)
                        (svtv-chase-data 'svtv-chase-data)
                        (aliases 'aliases)
                        (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svex-alist-vars (debugdata->override-assigns debugdata)))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (debugdata->modidx debugdata) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints (("goal" :in-theory (enable debugdatap)
                 :do-not-induct t)
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                )
  :returns (mv exitp new-svtv-chase-data new-state)
  (b* ((- (cw! "SVTV-CHASE > "))
       ((mv err obj state) (read-object *standard-oi* state))
       ((when err)
        (mv t svtv-chase-data state))
       ((when (natp obj))
        (b* ((vars (chase-vars svtv-chase-data))
             (stack (chase-stack svtv-chase-data))
             ((unless (consp stack))
              (cw! "Empty stack! Use (G \"path\" phase) to choose a signal, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((chase-position pos) (car stack))
             ((unless (< obj (len vars)))
              (cw "Out of range! Enter P to print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             ((cons new-var new-mask) (nth obj vars))
             (rsh (sparseint-trailing-0-count new-mask))
             (mask (sparseint-ash new-mask (- rsh)))
             ((mv new-var new-phase) (svtv-chase-normalize-var/phase new-var pos.phase))
             (name (svar->name new-var))
             ((unless (address-p name))
              (cw! "The chosen signal isn't an address, so it must be an ~
                    auxiliary variable supporting an override.~%Enter P to ~
                    print current state, ? for more options.~%")
              (mv nil svtv-chase-data state))
             (svtv-chase-data (svtv-chase-signal-data
                               (make-chase-position
                                :path (address->path name)
                                :phase new-phase
                                :rsh rsh :mask mask))))
          (mv nil svtv-chase-data state)))
       ((when (symbolp obj))
        (b* ((objname (symbol-name obj))
             ((when (equal objname "?"))
              (cw! *chase-usage*)
              (mv nil svtv-chase-data state))
             ((when (equal objname "P"))
              (svtv-chase-print!))
             ((when (equal objname "EXPR"))
              (cw! "~x0~%" (chase-expr svtv-chase-data))
              (mv nil svtv-chase-data state))
             ;; Too bad, walkabout isn't in logic mode
             ;; ((when (equal objname "WALK"))
             ;;  (b* (((mv ?err ?val state) (acl2::walkabout (chase-expr svtv-chase-data) state)))
             ;;    (mv nil svtv-chase-data state)))
             ((when (equal objname "B"))
              (b* ((stack (chase-stack svtv-chase-data))
                   ((unless (and (consp stack)
                                 (consp (cdr stack))))
                    (cw! "At end of stack!~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (update-chase-stack (cdr stack) svtv-chase-data)))
                (svtv-chase-print!)))
             ((when (equal objname "X"))
              (mv t svtv-chase-data state))
             ((when (equal objname "SMARTP"))
              (b* ((smartp (chase-smartp svtv-chase-data))
                   (new-smartp (not smartp))
                   (svtv-chase-data (update-chase-smartp new-smartp svtv-chase-data)))
                (cw! "Turned data-aware dependency reduction ~s0.~%"
                     (if new-smartp "on" "off"))
                (svtv-chase-print!))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state)))
       ((when (and (consp obj)
                   (symbolp (car obj))))
        (b* ((objname (symbol-name (car obj)))
             (args (cdr obj))
             ((when (equal objname "R"))
              (b* (((unless (and (consp args)
                                 (integerp (car args))
                                 (consp (cdr args))
                                 (integerp (cadr args))
                                 (not (cddr args))))
                    (cw! "R directive must be of the form (R MSB LSB) where MSB and LSB are integers.  ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (stack (chase-stack svtv-chase-data))
                   ((unless (consp stack))
                    (cw! "Empty stack! Use (G \"path\") to choose a signal, ? for more options.~%")
                    (mv nil svtv-chase-data state))
                   (pos (car stack))
                   (svtv-chase-data (svtv-chase-range pos (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "G"))
              (b* (((unless (and (consp args)
                                 (stringp (car args))
                                 (consp (cdr args))
                                 (natp (cadr args))
                                 (not (cddr args))))
                    (cw! "G directive must be of the form (G \"path\" phase) ~
                          where the first argument is a string and the second ~
                          is a natural number.~%")
                    (mv nil svtv-chase-data state))
                   (svtv-chase-data (svtv-chase-goto (car args) (cadr args))))
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EXPR"))
              (b* (((unless (and (consp args)
                                 (acl2::maybe-natp (car args))
                                 (not (cdr args))))
                    (cw! "EXPR directive must be of the form (EXPR depth).~%")
                    (mv nil svtv-chase-data state)))
                (acl2::fmt-to-comment-window! "~x0~%"
                                              `((#\0 . ,(chase-expr svtv-chase-data)))
                                              0 (evisc-tuple (car args) nil nil nil) nil)
                (mv nil svtv-chase-data state)))
             ((when (equal objname "EV"))
              (b* (((unless (and (consp args)
                                 (not (cdr args))))
                    (cw! "EV directive must be of the form (EV term).~%")
                    (mv nil svtv-chase-data state))
                   (attachment (fgetprop 'simple-translate-and-eval-logic 'acl2::attachment nil (w state)))
                   ((unless (and attachment
                                 (alistp attachment)
                                 (eq (cdr (assoc-eq 'simple-translate-and-eval-logic attachment))
                                     'acl2::simple-translate-and-eval-cmp)))
                    (cw! "In order to use EV you must set ~x0 as the ~
                          attachment for ~x1, as in the following ~
                          form:~%~x2~%Note that to (mostly) undo this you may ~
                          do:~%~x3~%"
                         'acl2::simple-translate-and-eval-cmp
                         'simple-translate-and-eval-logic
                         '(setup-ev-for-chase)
                         '(unsetup-ev-for-chase))
                    (mv nil svtv-chase-data state))
                   ((mv err term-dot-val)
                    (simple-translate-and-eval-logic (car args) nil nil "The argument to EV"
                                                     'svtv-chase-rep (w state) state t nil nil))
                   ((when (or err (not (consp term-dot-val))))
                    (cw! "Failed to evaluate: ~@0~%" term-dot-val)
                    (mv nil svtv-chase-data state)))
                (cw! "~x0~%" (cdr term-dot-val))
                (mv nil svtv-chase-data state))))
          (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
          (mv nil svtv-chase-data state))))
    (cw! "Error -- unrecognized directive: ~x0~%Type ? for allowed commands.~%" obj)
    (mv nil svtv-chase-data state))
  ///
  (defret file-measure-of-svtv-chase-rep-weak
    (<= (file-measure *standard-oi* new-state)
        (file-measure *standard-oi* state))
    :rule-classes :linear)

  (defret file-measure-of-svtv-chase-rep-strong
    (implies (not exitp)
             (< (file-measure *standard-oi* new-state)
                (file-measure *standard-oi* state)))
    :rule-classes :linear)

  (defret open-input-channel-p1-of-<fn>
    (implies (open-input-channel-p1 *standard-oi* :object state)
             (open-input-channel-p1 *standard-oi* :object new-state))))

  

(define svtv-chase-repl (&key
                         (debugdata 'debugdata)
                         ((moddb moddb-ok) 'moddb)
                         (aliases 'aliases)
                         (svtv-chase-data 'svtv-chase-data)
                         (state 'state))
  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svexlist-collect-vars (svex-alist-vals (debugdata->override-assigns debugdata))))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (debugdata->modidx debugdata) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints ((and stable-under-simplificationp
                     '(:in-theory (enable debugdatap)
                       :do-not-induct t)))
  :returns (mv new-svtv-chase-data new-state)
  :measure (file-measure *standard-oi* state)
  (b* (((mv exitp svtv-chase-data state) (svtv-chase-rep))
       ((when exitp)
        (cw! "~%Exiting SVTV-CHASE.  You may execute ~x0 to re-enter or ~x1 ~
              to change the simulation inputs.~%"
             '(svtv-chase-repl) '(svtv-chase-update env))
        (mv svtv-chase-data state)))
    (svtv-chase-repl)))


(defthm nth-of-svtv-debug-set-ios-logic
  (implies (not (member (nfix n)
                        (list *debugdata->updates*
                              *debugdata->nextstates*
                              *debugdata->ins*
                              *debugdata->outs*
                              *debugdata->overrides*
                              *debugdata->override-assigns*
                              *debugdata->status*
                              *debugdata->nphases*)))
           (equal (nth n (svtv-debug-set-ios-logic :ins ins :outs outs :internals internals
                                                   :overrides overrides
                                                   :rewrite rewrite))
                  (nth n debugdata)))
  :hints(("Goal" :in-theory (enable svtv-debug-set-ios-logic))))

(defthm nth-of-svtv-debug-set-svtv
  (implies (not (member (nfix n)
                        (list *debugdata->updates*
                              *debugdata->nextstates*
                              *debugdata->ins*
                              *debugdata->outs*
                              *debugdata->overrides*
                              *debugdata->override-assigns*
                              *debugdata->status*
                              *debugdata->nphases*)))
           (equal (nth n (svtv-debug-set-svtv x :rewrite rewrite))
                  (nth n debugdata)))
  :hints(("Goal" :in-theory (enable svtv-debug-set-svtv))))


(defthm svex-alist-p-updates-of-svtv-debug-set-ios-logic
  (implies (svex-alist-p (nth *debugdata->updates* debugdata))
           (svex-alist-p (nth *debugdata->updates*
                              (svtv-debug-set-ios-logic :ins ins
                                                        :outs outs
                                                        :internals internals
                                                        :overrides overrides
                                                        :rewrite rewrite))))
  :hints(("Goal" :in-theory (enable svtv-debug-set-ios-logic))))

(defthm svex-alist-p-override-assigns-of-svtv-debug-set-ios-logic
  (implies (svex-alist-p (nth *debugdata->override-assigns* debugdata))
           (svex-alist-p (nth *debugdata->override-assigns*
                              (svtv-debug-set-ios-logic :ins ins
                                                        :outs outs
                                                        :internals internals
                                                        :overrides overrides
                                                        :rewrite rewrite))))
  :hints(("Goal" :in-theory (enable svtv-debug-set-ios-logic))))

(defthm svex-alist-p-nextstates-of-svtv-debug-set-ios-logic
  (implies (svex-alist-p (nth *debugdata->nextstates* debugdata))
           (svex-alist-p (nth *debugdata->nextstates*
                              (svtv-debug-set-ios-logic :ins ins
                                                        :outs outs
                                                        :internals internals
                                                        :overrides overrides
                                                        :rewrite rewrite))))
  :hints(("Goal" :in-theory (enable svtv-debug-set-ios-logic))))

(local (in-theory (disable append
                           true-listp
                           len
                           not
                           (tau-system)
                           svarlist-addr-p-by-badguy)))

;; BOZO include in ../mods/compile.lisp
;; (defret vars-of-svex-design-flatten-and-normalize-aliases
;;   (implies (and (not err)
;;                 (not indexedp))
;;            (svarlist-addr-p (aliases-vars new-aliases)))
;;   :hints(("Goal" :in-theory (enable svex-design-flatten-and-normalize)))
;;   :fn svex-design-flatten-and-normalize)

(define svtv-chase-update ((env svex-env-p)
                           &key
                           (debugdata 'debugdata)
                           ((moddb moddb-ok) 'moddb)
                           (aliases 'aliases)
                           (svtv-chase-data 'svtv-chase-data)
                           (state 'state))

  :guard (and (open-input-channel-p *standard-oi* :object state)
              ;; (svarlist-addr-p (svexlist-collect-vars (svex-alist-vals (debugdata->override-assigns debugdata))))
              ;; (svarlist-addr-p (svar-map-vars (debugdata->delays debugdata)))
              (< (debugdata->modidx debugdata) (moddb->nmods moddb))
              (<= (moddb-mod-totalwires (debugdata->modidx debugdata) moddb)
                  (aliass-length aliases))
              ;; (svarlist-addr-p (aliases-vars aliases))
              )
  :guard-hints (("goal" :in-theory (enable debugdatap)
                 :do-not-induct t)
                ;; (and stable-under-simplificationp
                ;;      '(:in-theory (enable chase-position-addr-p)))
                )
  :returns (mv new-debugdata new-svtv-chase-data new-state)
  (b* ((evaldata (svtv-chase-inalist-to-evaldata env))
       (svtv-chase-data (update-chase-stack nil svtv-chase-data))
       (svtv-chase-data (update-chase-evaldata evaldata svtv-chase-data))
       (svtv-chase-data (update-chase-smartp t svtv-chase-data))
       (debugdata (set-debugdata->updates (make-fast-alist (debugdata->updates debugdata)) debugdata))
       (debugdata (set-debugdata->override-assigns
                   (make-fast-alist (debugdata->override-assigns debugdata)) debugdata))
       (debugdata (set-debugdata->delays (make-fast-alist (debugdata->delays debugdata)) debugdata))
       (debugdata (set-debugdata->nextstates (make-fast-alist (debugdata->nextstates debugdata)) debugdata))
       (- 
        (cw! "Entering SVTV-CHASE Read-Eval-Print Loop~%")
        (cw! "Enter X to exit~%")
        (cw! "Enter ? for command list~%"))
       ((mv svtv-chase-data state) (svtv-chase-repl)))
    (mv debugdata svtv-chase-data state)))

(define svtv-chase ((x svtv-p)
                    (env svex-env-p)
                    &key
                    (debugdata 'debugdata)
                    ((moddb moddb-ok) 'moddb)
                    (aliases 'aliases)
                    (svtv-chase-data 'svtv-chase-data)
                    (state 'state)
                    (rewrite 't))
  :returns (mv new-debugdata new-moddb new-aliases new-svtv-chase-data new-state)
  :guard (open-input-channel-p *standard-oi* :object state)
  :guard-hints (("goal" :do-not-induct t)
                (and stable-under-simplificationp
                     '(:in-theory (enable svtv-debug-init
                                          svtv-debug-set-svtv)))
                (and stable-under-simplificationp
                     '(:in-theory (enable debugdatap))))
  (b* (((svtv x))
       (mod-fn (intern-in-package-of-symbol
                (str::cat (symbol-name x.name) "-MOD")
                x.name))
       ((mv err design)
        (acl2::magic-ev-fncall mod-fn nil state t t))
       ((when err)
        (cw! "Couldn't run ~x0: ~@1~%" mod-fn err)
        (mv debugdata moddb aliases svtv-chase-data state))
       ((unless (and (design-p design)
                     (modalist-addr-p (design->modalist design))))
        (cw! "~x0 returned a malformed design~%" mod-fn)
        (mv debugdata moddb aliases svtv-chase-data state))
       ((mv err moddb aliases debugdata) (svtv-debug-init design))
       ((when err)
        (mv debugdata moddb aliases svtv-chase-data state))
       (debugdata (svtv-debug-set-svtv x :rewrite rewrite))
       ((mv debugdata svtv-chase-data state)
        (svtv-chase-update env)))
    (mv debugdata moddb aliases svtv-chase-data state)))


